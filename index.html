<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GitHub 電子書閱讀器</title>
    <style>
        :root { --bg-color: #333; }
        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            
            /* 解決方案 B-1 加強版：
               直接設為 none，告訴瀏覽器「不要處理任何手勢（包含滑動、縮放）」，
               全部交給 JS 處理。這比 manipulation 更徹底。
            */
            touch-action: none; 
            
            user-select: none;
            -webkit-user-select: none;
        }

        .viewport-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        /* 觸控區 */
        .stage-area {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; 
            perspective: 1500px;
            padding: 10px;
            position: relative;
            /* 再次強調禁止原生手勢 */
            touch-action: none; 
        }

        .hint-text {
            position: absolute;
            top: 15px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 20px;
            z-index: 50;
            pointer-events: none;
            opacity: 0.6;
        }

        .book {
            position: relative;
            transform-style: preserve-3d;
            aspect-ratio: 9 / 16;
            height: 100%;
            max-height: 100%;
            width: auto;
            max-width: 100%;
        }

        .page {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            transition: transform 0.6s cubic-bezier(0.645, 0.045, 0.355, 1);
            transform-origin: left center;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .img-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            will-change: transform;
        }

        .page img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .page.flipped { transform: rotateY(-180deg); }
        .page.active { z-index: 10; }

        /* --- 控制列 --- */
        .controls {
            flex-shrink: 0;
            height: 70px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding-bottom: env(safe-area-inset-bottom);
            z-index: 100;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 15px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            width: 95%; 
            max-width: 400px;
            flex-wrap: nowrap; 
        }

        button {
            border: none;
            background: #333;
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            flex-shrink: 0;
        }
        button:disabled { background: #ccc; opacity: 0.5; }
        
        .page-info { font-weight: bold; color: #333; font-size: 14px; white-space: nowrap; flex-shrink: 0; }
        .jump-box { display: flex; align-items: center; gap: 5px; border-left: 1px solid #ccc; padding-left: 8px; flex-shrink: 1; }
        input { width: 35px; text-align: center; border-radius: 5px; border: 1px solid #ddd; padding: 5px 0; }
        .btn-go { width: auto; border-radius: 15px; padding: 0 10px; font-size: 12px; height: 30px; }

    </style>
</head>
<body>

    <div class="viewport-container">
        <div class="stage-area" id="touch-stage">
            <div class="hint-text" id="status-hint">滑動翻頁 • 雙指縮放</div>
            <div class="book" id="book">
                <div class="page active" id="page-0">
                    <div class="img-container" id="zoom-container-0">
                        <img src="0.JPG" alt="Page 1">
                    </div>
                </div>
                <div class="page" id="page-1">
                    <div class="img-container" id="zoom-container-1">
                        <img src="1.JPG" alt="Page 2">
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-panel">
                <button id="btn-prev" onclick="manualPrev()">❮</button>
                <span class="page-info"><span id="current-page">1</span> / <span id="total-pages">2</span></span>
                <button id="btn-next" onclick="manualNext()">❯</button>
                <div class="jump-box">
                    <input type="number" id="jump-input" placeholder="頁">
                    <button class="btn-go" onclick="jumpToPage()">GO</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const totalImages = 2;
        let currentIndex = 0;

        let state = { scale: 1, x: 0, y: 0 };
        let startDist = 0; 
        let startScale = 1; 
        let startX = 0;
        let startY = 0;
        let lastX = 0; 
        let lastY = 0;
        let isPinching = false;
        let isDragging = false;

        const touchStage = document.getElementById('touch-stage');
        const hintText = document.getElementById('status-hint');

        function init() {
            document.getElementById('total-pages').innerText = totalImages;
            updateUI();

            // --- 解決方案 B-3：iOS 專用防禦 (最重要) ---
            // 監聽 gesturestart 並阻止它，這能讓 iOS Safari 不會執行原生的兩指縮放網頁
            document.addEventListener('gesturestart', function(e) {
                e.preventDefault();
            });

            // --- 防止雙擊放大 (B-2 的延伸) ---
            // 雖然我們已經用 touch-action: none，但加這層 JS 防禦更保險
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // 綁定我們的自定義觸控事件
            touchStage.addEventListener('touchstart', handleTouchStart, { passive: false });
            touchStage.addEventListener('touchmove', handleTouchMove, { passive: false });
            touchStage.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function getDistance(touches) {
            return Math.hypot(
                touches[0].clientX - touches[1].clientX,
                touches[0].clientY - touches[1].clientY
            );
        }

        function handleTouchStart(e) {
            // --- 解決方案 B-2 加強 ---
            // 如果偵測到兩指以上，強制阻止原生行為，確保只執行我們的邏輯
            if (e.touches.length > 1) {
                e.preventDefault(); 
            }

            const touches = e.touches;
            if (touches.length === 2) {
                isPinching = true;
                isDragging = false;
                startDist = getDistance(touches);
                startScale = state.scale;
                hintText.innerText = "縮放中...";
            } else if (touches.length === 1) {
                isPinching = false;
                isDragging = false; 
                startX = touches[0].clientX;
                startY = touches[0].clientY;
                lastX = startX;
                lastY = startY;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault(); // 這裡也很重要，防止單指拖曳時畫面捲動
            const touches = e.touches;

            if (isPinching && touches.length === 2) {
                // 自定義縮放邏輯
                const currentDist = getDistance(touches);
                const scaleFactor = currentDist / startDist;
                let newScale = startScale * scaleFactor;
                newScale = Math.max(1, Math.min(newScale, 4));
                state.scale = newScale;
                updateTransform();

            } else if (touches.length === 1) {
                // 自定義移動邏輯
                const deltaX = touches[0].clientX - lastX;
                const deltaY = touches[0].clientY - lastY;
                lastX = touches[0].clientX;
                lastY = touches[0].clientY;

                if (state.scale > 1.05) {
                    state.x += deltaX;
                    state.y += deltaY;
                    updateTransform();
                    isDragging = true; 
                    hintText.innerText = "拖曳移動";
                } else {
                    isDragging = true; 
                }
            }
        }

        function handleTouchEnd(e) {
            if (isPinching && e.touches.length < 2) {
                isPinching = false;
                if (state.scale < 1.1) resetZoom();
                return;
            }
            if (!isPinching && isDragging) {
                if (state.scale <= 1.05) {
                    const endX = e.changedTouches[0].clientX;
                    const totalDeltaX = endX - startX;
                    if (Math.abs(totalDeltaX) > 50) {
                        if (totalDeltaX < 0) nextPage();
                        else prevPage();
                    }
                }
            }
        }

        function updateTransform() {
            const container = document.getElementById(`zoom-container-${currentIndex}`);
            if (container) {
                container.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
            }
        }

        function resetZoom() {
            state = { scale: 1, x: 0, y: 0 };
            const container = document.getElementById(`zoom-container-${currentIndex}`);
            if (container) {
                container.style.transition = 'transform 0.3s ease-out';
                container.style.transform = `translate(0px, 0px) scale(1)`;
                setTimeout(() => { container.style.transition = 'none'; }, 300);
            }
            hintText.innerText = "滑動翻頁 • 雙指縮放";
        }

        function nextPage() {
            if (currentIndex >= totalImages - 1) return;
            const oldContainer = document.getElementById(`zoom-container-${currentIndex}`);
            if(oldContainer) oldContainer.style.transform = 'none';
            state = { scale: 1, x: 0, y: 0 };
            document.getElementById(`page-${currentIndex}`).classList.add('flipped');
            currentIndex++;
            updateUI();
        }

        function prevPage() {
            if (currentIndex <= 0) return;
            const oldContainer = document.getElementById(`zoom-container-${currentIndex}`);
            if(oldContainer) oldContainer.style.transform = 'none';
            state = { scale: 1, x: 0, y: 0 };
            currentIndex--;
            document.getElementById(`page-${currentIndex}`).classList.remove('flipped');
            updateUI();
        }

        function manualNext() { if(state.scale <= 1.05) nextPage(); else resetZoom(); }
        function manualPrev() { if(state.scale <= 1.05) prevPage(); else resetZoom(); }

        function jumpToPage() {
            const input = document.getElementById('jump-input');
            let targetPage = parseInt(input.value);
            if (isNaN(targetPage) || targetPage < 1 || targetPage > totalImages) return;
            const oldContainer = document.getElementById(`zoom-container-${currentIndex}`);
            if(oldContainer) oldContainer.style.transform = 'none';
            state = { scale: 1, x: 0, y: 0 };
            let targetIndex = targetPage - 1;
            if (targetIndex > currentIndex) {
                for (let i = currentIndex; i < targetIndex; i++) document.getElementById(`page-${i}`).classList.add('flipped');
            } else {
                for (let i = currentIndex - 1; i >= targetIndex; i--) document.getElementById(`page-${i}`).classList.remove('flipped');
            }
            currentIndex = targetIndex;
            updateUI();
            input.value = '';
        }

        function updateUI() {
            for (let i = 0; i < totalImages; i++) {
                const page = document.getElementById(`page-${i}`);
                if (i > currentIndex) {
                    page.style.zIndex = totalImages - i;
                    page.style.display = 'flex';
                } else if (i === currentIndex) {
                    page.style.zIndex = totalImages + 1;
                    page.style.display = 'flex';
                    page.classList.add('active');
                } else {
                    page.style.zIndex = i;
                    page.classList.remove('active');
                }
            }
            document.getElementById('current-page').innerText = currentIndex + 1;
            document.getElementById('btn-prev').disabled = (currentIndex === 0);
            document.getElementById('btn-next').disabled = (currentIndex === totalImages - 1);
        }

        init();
    </script>
</body>
</html>
